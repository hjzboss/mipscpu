# 简单五级流水的32位mips cpu

该cpu实现了五级流水，解决了数据相关的问题，但是没有很好地解决控制相关。能够完成基本的运算，并拥有输入和输出功能，能够在FPGA开发板上很好的实现。只实现了9条基本mips指令加上改编的输入和输出指令，其中输入输出指令用于在fpga开发板上读取数据和输出数据

## cpu结构

五级流水，分别为：

* 取指（IF）：取出指令
* 译码（ID）：对取出的指令进行译码，发出控制信号
* 执行（EX）：进行逻辑和算术运算
* 访存（MEM）：访问存储器或者输入输出
* 写回（WB）：将数据写回寄存器堆

在每个模块之间都有一个流水线寄存器，在每个时钟周期的上升沿将前一个模块的数据送往下一个模块。并且综合了两个32位的存储器：数据存储器和指令存储器。

## 指令集

采用的是mips的指令集，但只实现了其中9条的功能：

| 指令符  | op[31:26] | rs[25:21] | rt[20:16] | rd[15:11] | shamt[10:6] | funct[5:0] | 功能    | 格式           | 功能描述               |
| ---- | --------- | --------- | --------- | --------- | ----------- | ---------- | ----- | ------------ | ------------------ |
| ADD  | 000000    | rs        | rt        | rd        | 00000       | 100000     | 寄存器加  | Add rd,rs,rt | Rd = rt + rs       |
| SUB  | 000000    | rs        | rt        | rd        | 00000       | 100010     | 寄存器减  | Sub rd,rs,rt | Rd = rs - rt       |
| AND  | 000000    | rs        | rt        | rd        | 00000       | 100100     | 寄存器与  | And rd,rs,rt | Rd = rs & rt       |
| OR   | 000000    | rs        | rt        | rd        | 00000       | 100101     | 寄存器或  | Or rd,rs,rt  | Rd = rs \| rt      |
| SLT  | 000000    | rs        | rt        | rd        | 00000       | 101010     | 小于则置位 | Slt rd,rs,rt | Rd = (rs<rt?)  1:0 |

 

| 指令   | op[31:26] | address[25:0] | 功能   | 格式        | 功能描述               |
| ---- | --------- | ------------- | ---- | --------- | ------------------ |
| J    | 000010    | Address       | 跳转指令 | J address | Goto  (address<<2) |

 

| 指令   | op[31:26] | rs[25:21] | rt[20:16] | address[15:0] | 功能    | 格式               | 功能描述                              |         |
| ---- | --------- | --------- | --------- | ------------- | ----- | ---------------- | --------------------------------- | ------- |
| LW   | 100011    | rs        | rt        | offset        | 取数指令  | Lw rt,rs(offset) | Rt=memory(rs+offset)              | Rt = in |
| SW   | 101011    | rs        | rt        | offset        | 存数指令  | Sw rt,rs(offset) | Memory(rs+offset)=rt              | Out= rt |
| BEQ  | 000100    | rs        | rt        | offset        | 相等则跳转 | Beq rs,rt,offset | If(rs == rt) goto  pc+4+offset<<4 |         |

LW指令可以用于读取输入的数据，如果地址的最高位为1时，会从输入寄存器读取数据进入寄存器。

SW指令还可以用于输出数据，只需让其地址最高位为1即可输出数据至输出寄存器。

##  项目结构

* data目录下为测试程序的机器码
* intel_core_i999.v 为cpu
* intel_core_i999_min_sopc_tb.v为TestBench文件
* intel_core_i999_min_sopc.v为一个简单的sopc，连接了存储器和分频器
* id，mem，ex为译码，访存和执行模块
* ex_mem类似的文件为流水线寄存器
* inst_rom为指令存储器
* data_ram为数据存储器
* defines.v为宏定义
* ctrl为控制器
* fp为分频器
* regfile为寄存器文件



### 参考书籍

《自己动手写CPU》

《计算机组成与设计：软硬件接口》